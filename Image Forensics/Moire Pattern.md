#  基于摩尔纹分析识别脸部盗用

>  Face-Spoofing 2D-Detection Based on Moire-Pattern Analysis
>
>  Diogo Caetano Garcia and Ricardo L. de Queiroz

## Part 1 简介

通过打印图片或设备屏幕，我们可以轻易欺骗面部识别系统。现在已经有很多欺骗检测方法[2]-[19]。包括图像质量分析，动作分析，材质分析和上述方法的组合。以下简称具有欺骗性质的图像(spoofing image)为假图。

-  图像质量分析方法：[2]定义一种高频描述其和低阈值来区分常规和假图。[3]用SVM查找缺少高频信息的图像来找出假图。[4]中查找不可能的光照变换识别假图。[5]基于对比度受限直方图均衡(CLAHE, Contrast-Limited Adaptive histgram equalization) 。[6]用25种常规图质量特征来识别假图。
-  动作分析方法：[7]寻找动作不连贯性。[8]构建一系列的面部识别点寻找几何不变点。[9]通过对比面部的不同部分的动作来识别。
-  材质分析方法：[10]根据噪声频率签名区分。[11]在块级运用局部二值模式(LBP, Local Binary Patter)算法，计算直方图，用SVM分类信息查找材质不连续点。[12]在前面的工作上添加了测试不同的分类器。[13]，[14]在行为放大序列上应用材质分析法。[15]将功率谱和本地二值模式组合分析。[16]，[17]计算特定组件梯度的直方图。

## Part 2 假图的特征

与真实环境用户的模拟现实环境不同，假图依赖于电子媒体。因此相机的栅格会与电子媒体的栅格重叠。对于打印出的图片，相机的图像栅格会与打印的半色调点(halftoning dots)重合。对于电子屏幕，相机的图像栅格会与像素栅格重合。

[22]-[24]详细的介绍了`摩尔纹(Moire Pattern)`。考虑一个连续空间的低通函数$f(t)$,我们在相同的时间间隔上取样。在$T_1$取样渲染为$f_s(nT_1)$。$f(t)$和$f_s(nT_1)$在傅里叶变换后依次为$F(\omega)$和$F_s(\omega)=\sum_kF(\omega-2 \pi k/T_1)$。当屏幕上展示$f_s(nT_1)$时，真正渲染的是矩形加窗函数计算的卷积$f_{sd}(t)$，或者是$F_s(\omega)$与$sinc$函数的乘积。随后$f_{sd}(t)$被数码相机拍摄了，取样间隔为$T_2$。$T_2$取决于两个因素，相机像素尺寸和屏幕和相机的距离。当屏幕和相机的距离增加时，$T_2$成比例增加，减小了获取的分辨率。相机上的取样频率$1/T_2 \gt 1/T_1$或者说$T_1 \gt T_2$[22]，说明出现的摩尔纹会非常难直接衡量。设$SR=\frac{T_1}{T_2}$，可以近似用像素比$PR=N_2/N_1$表示。其中$N_1$和$N_2$表示像素长度。随着相机和屏幕之间的距离增长，$T_2$也会增长，$SR$降低。像素长度$N_2$和$PR$会按比例减少。因此$T_1 \gt T_2$是摩尔纹出现的条件。

## Part 3 提出算法

我们描述的算法假设假照片在高频区域会有不正常的峰值。目标是找到这些峰值，而不是基带。然而并没有什么方法可以决定应该忽略多少基带，所以算法需要在不同的频带查找峰值。给出一个识别面部的图片$I$，生成出`带通滤波器(band-pass-filtered)`的图片版本。使用峰值检测器检查这些版本的`DFT`的绝对值。如果检测到峰值，则认为是假图片。每个带通滤波器的版本$I_{BP}$通过$I$与`高斯差(DoG, difference-of-Gaussians)过滤器`的卷积得到：
$$
D(\sigma, k) = G(0, \sigma^2)-G(0, k\sigma^2)
$$
其中$G(0, \sigma^2)$是一个零平均，标准偏差$\sigma$的2D高斯函数。参数$k$决定了频带的宽度，$\sigma$定义了频带的中心。经过多次试验，最好的参数是$k=2, \sigma_0=0.1, \sigma_{max}=1.1,\Delta=0.2$。

峰值检测器算法基于最大相关阈值(maxium-correlation thresholding)[26]。给出任意图片$A$, 阈值版本$B= \tau \{A\}$。定义如下：
$$
B(u, v)=\tau\{A(u, v)\}=
\begin{cases}
1& \text{}A(u, v)\gt1\\
0& \text{}A(u, v)\leq t
\end{cases}
$$
其中$t$是A与B之间相关性$\rho_{AB}$的最大值点：
$$
\rho_{AB} = \frac{E_{AB}-E_AE_B}{\sqrt{(E_{AA}-E_A^2)(E_{BB}-E_B^2)}} \\
E_A=\sum_{g=0}^n g \cdot p(g) \\
E_{AA}=\sum_{g=0}^n g^2 \cdot p(g) \\
E_B=\sum_{g=0}^t \mu_0(t) \cdot p(g)+ \sum_{g=t+1}^n \mu_1(t)\cdot p(g)  \\
E_{BB}=\sum_{g=0}^t \mu_0^2(t) \cdot p(g)+ \sum_{g=t+1}^n \mu_1^2(t)\cdot p(g)  \\
E_{AB}=\sum_{g=0}^tg \mu_0(t) \cdot p(g)+ \sum_{g=t+1}^n g\mu_1(t)\cdot p(g)  \\
$$
其中$g$是$n+1$种$A(u,v)$可能的灰度值之一， $p(g)$是可能的灰度级。$g\cdot p(g)$是$A(u,v)$的近似直方图。$ \mu_0(t) $和$ \mu1(t) $是低于和高于阈值的方法：
$$
\mu_0(t) =\frac{\sum_{g=0}^t g\cdot p(g)}{\sum_{g=0}^t p(g)} \\
 \mu_1(t)=\frac{\sum_{g=t+1}^n g \cdot p(g)}{\sum_{g=t+1}^n p(g)}
$$
